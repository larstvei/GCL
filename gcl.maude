set show advisories off .

load prelude.maude

fmod VAR is
    including QID .
    sort Var .
    subsort Qid < Var .
endfm

view Var from TRIV to VAR is
    sort Elt to Var .
endv

fmod EXPR is
    pr VAR .
    pr INT .
    pr BOOL .

    sort Expr .
    subsorts Bool Int Var < Expr .

    op _+_ : Expr Expr -> Expr [ditto] .
    op _*_ : Expr Expr -> Expr [ditto] .
    op not_ : Expr -> Expr [ditto] .
    op _and_ : Expr Expr -> Expr [ditto] .
    op _or_ : Expr Expr -> Expr [ditto] .
    op _=:=_ : Expr Expr -> Bool [prec 25] .
    op _<_ : Expr Expr -> Expr [ditto] .
endfm

view Expr from TRIV to EXPR is
    sort Elt to Expr .
endv

fmod STATE is
    pr VAR .
    pr EXPR .
    pr MAP{Var, Expr} .

    sort Substitution .
    subsort Map{Var, Expr} < Substitution .
endfm

fmod EVAL is
    pr EXPR .
    pr STATE .

    var M : Substitution .
    var N : Int .
    var B : Bool .
    var V : Var .
    vars E1 E2 : Expr .

    op eval : Substitution Expr -> Expr .
    eq eval(M, N) = N .
    eq eval(M, B) = B .
    eq eval(M, V) = M[V] .
    eq eval(M, E1 + E2) = eval(M, E1) + eval(M, E2) .
    eq eval(M, E1 * E2) = eval(M, E1) * eval(M, E2) .
    eq eval(M, not(E1)) = not(eval(M, E1)) .
    eq eval(M, E1 and E2) = eval(M, E1) and eval(M, E2) .
    eq eval(M, E1 or E2) = eval(M, E1) or eval(M, E2) .
    eq eval(M, E1 =:= E1) = true .
    eq eval(M, E1 < E2) = eval(M, E1) < eval(M, E2) .
    eq eval(M, E1 =:= E2) = eval(M, E1) =:= eval(M, E2) [owise].

endfm

fmod GCL-STATEMENTS is
    pr EXPR .

    sorts GuardStm Statement .

    op _|>_ : Expr Statement -> GuardStm [prec 95] .
    op _<|_|>_ : Statement Expr Statement -> GuardStm [prec 95] .
    op _;_ : GuardStm GuardStm -> GuardStm [assoc prec 100 id: idle format (d d ni d)] .
    op skip : -> GuardStm .
    op idle : -> GuardStm .
    op _:=_ : Var Expr -> Statement [prec 90] .
    op spawn_ : GuardStm -> Statement .
endfm

fmod PROCESS is
    pr NAT .
    pr LIST{Nat} .
    pr GCL-STATEMENTS .

    sorts Process ThreadId .
    subsorts List{Nat} < ThreadId .

    op iota<_>(_) : ThreadId GuardStm -> Process .
    op iota<_,_>(_) : ThreadId Nat GuardStm -> Process [format (ni d d d d ni d d d)] .
    var I : ThreadId .
    var g : GuardStm .
    eq iota< I > (g) = iota< I, 0 > (g) .
endfm

view Process from TRIV to PROCESS is
    sort Elt to Process .
endv

fmod RUNTIME-SYNTAX is
    pr PROCESS .
    pr STATE .
    pr SET{Process} .

    sorts Processes RuntimeState .
    subsort Set{Process} < Processes .
    op {_|_} : Substitution Processes -> RuntimeState .
    op {step |_|_} : Substitution Processes -> RuntimeState .
    op {done |_|_} : Substitution Processes -> RuntimeState .
endfm

mod GCL-SEMANTICS is
    pr EVAL .
    pr RUNTIME-SYNTAX .
    pr GCL-STATEMENTS .

    vars Sigma Sigma' : Substitution .
    vars g g' : GuardStm .
    vars s1 s2 : Statement .
    vars e e' : Expr .
    var I : ThreadId .
    var N : Nat .
    var x : Var .
    vars P P' : Processes .

    rl [Skip] :
        { step | Sigma | iota< I, N > (skip ; g) }
      =>
        { done | Sigma | iota< I, N > (g) } .

    crl [Assignment] :
        { step | Sigma | iota< I, N > (e |> x := e' ; g) }
      =>
        { done | Sigma' | iota< I, N > (g) }
      if eval(Sigma, e) == true /\
          Sigma' := insert(x, eval(Sigma, e'), Sigma) .

    crl [Spawn] :
        { step | Sigma | iota< I, N > (e |> spawn(g') ; g) }
      =>
        { done | Sigma | iota< I, s(N) > (g), iota< I N > (g') }
      if eval(Sigma, e) == true .

    crl [Choice1] :
        { step | Sigma | iota< I, N > (s1 <| e |> s2 ; g) }
      =>
        { done | Sigma' | P }
      if { step | Sigma | iota< I, N > (e |> s1 ; g) }
        => { done | Sigma' | P } .

    crl [Choice2] :
        { step | Sigma | iota< I, N > (s1 <| e |> s2 ; g) }
      =>
        { done | Sigma' | P }
      if { step | Sigma | iota< I, N > ((not e) |> s2 ; g) }
        => { done | Sigma' | P } .

    crl [Interleaving] :
        { Sigma | P, iota< I, N > (g) }
      =>
        { Sigma' | P, P' }
      if { step | Sigma | iota< I, N > (g) }
        => { done | Sigma' | P' } .
endm

fmod TRACE is
    pr PROCESS .
    sort Label .

    op epsilon : -> Label .
    op _[_ |> _ := _] : ThreadId Expr Var Expr -> Label .
    op _[_ |> spawn(_)] : ThreadId Expr ThreadId -> Label .

    sort Trace .
    subsort Label < Trace .

    op _++_ : Trace Trace -> Trace [assoc id: epsilon format (d d ni d)] .
endfm

fmod LABELED-RUNTIME-SYNTAX is
    pr TRACE .
    pr RUNTIME-SYNTAX .

    op {_|_|_} : Trace Substitution Processes -> RuntimeState
        [format (n+ ni ni d ni d n- d)].
    op {step |_|_} : Substitution Processes -> RuntimeState .
    op {done |_|_|_} : Label Substitution Processes -> RuntimeState .
endfm


mod GCL-CONCOLIC-SEMANTICS is
    pr EVAL .
    pr LABELED-RUNTIME-SYNTAX .
    pr GCL-STATEMENTS .

    vars Sigma Sigma' : Substitution .
    vars g g' : GuardStm .
    vars s1 s2 : Statement .
    vars e e' : Expr .
    var I : ThreadId .
    var N : Nat .
    var x : Var .
    vars P P' : Processes .
    vars theta : Trace .
    vars l : Label .

    rl [Skip] :
        { step
          | Sigma
          | iota< I, N > (skip ; g) }
      =>
        { done
          | epsilon
          | Sigma
          | iota< I, N > (g) } .

    crl [Assignment] :
        { step
          | Sigma
          | iota< I, N > (e |> x := e' ; g) }
      =>
        { done
          | I[e |> x := e']
          | Sigma'
          | iota< I, N > (g) }
      if eval(Sigma, e) == true /\
          Sigma' := insert(x, eval(Sigma, e'), Sigma) .

    crl [Spawn] :
        { step
          | Sigma
          | iota< I, N > (e |> spawn(g') ; g) }
      =>
        { done
          | I[e |> spawn(I N)]
          | Sigma
          | iota< I, s(N) > (g), iota< I N > (g') }
      if eval(Sigma, e) == true .

    crl [Choice1] :
        { step
          | Sigma
          | iota< I, N > (s1 <| e |> s2 ; g) }
      =>
        { done
          | l
          | Sigma'
          | P }
      if { step
            | Sigma
            | iota< I, N > (e |> s1 ; g) }
        => { done
            | l
            | Sigma'
            | P } .

    crl [Choice2] :
        { step
          | Sigma
          | iota< I, N > (s1 <| e |> s2 ; g) }
      =>
        { done
          | l
          | Sigma'
          | P }
      if { step | Sigma | iota< I, N > ((not e) |> s2 ; g) }
        => { done | l | Sigma' | P } .

    crl [Interleaving] :
        { theta
          | Sigma
          | P, iota< I, N > (g) }
      =>
        { theta ++ l
          | Sigma'
          | P, P' }
      if { step
            | Sigma
            | iota< I, N > (g) }
        => { done
            | l
            | Sigma'
            | P' } .
endm

fmod PATH is
    pr BOOL .
    pr TRACE .

    sort Substitution .

    op path : Trace -> Expr .
    op [_/_] : Expr Var -> Substitution .
    op __ : Expr Substitution -> Expr [prec 20] .
    op _/\_ : Expr Expr -> Expr [assoc comm format (n d d d)] .

    var theta : Trace .
    var x : Var .
    vars e e' e1 e2 : Expr .
    vars I I' : ThreadId .
    vars C1 C2 : Expr .

    eq path(epsilon) = true .
    eq path((I[e |> x := e']) ++ theta) = e /\ (path(theta)[e' / x]) .
    eq path((I[e |> spawn(I')]) ++ theta) = e /\ path(theta) .

    eq x[e / x] = e .
    eq (e1 + e2)[e / x] = e1[e / x] + e2[e / x] .
    eq (e1 * e2)[e / x] = e1[e / x] * e2[e / x] .
    eq (not e')[e / x] = not(e'[e / x]) .
    eq (e1 and e2)[e / x] = e1[e / x] and e2[e / x] .
    eq (e1 or e2)[e / x] = e1[e / x] or e2[e / x] .
    eq (e1 =:= e2)[e / x] = e1[e / x] =:= e2[e / x] .
    eq (e1 < e2)[e / x] = e1[e / x] < e2[e / x] .
    eq (C1 /\ C2)[e / x] = C1[e / x] /\ C2[e / x] .

    eq not not e = e .

    eq e /\ e = e .
    eq e /\ true = e .
    eq e'[e / x] = e' [owise] .

endfm
